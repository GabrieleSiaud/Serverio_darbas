// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: external_cache.sql

package repository

import (
	"context"
	"time"
)

const deleteExpiredExternalCache = `-- name: DeleteExpiredExternalCache :exec
DELETE FROM external_api_cache
WHERE expires_at <= NOW()
`

func (q *Queries) DeleteExpiredExternalCache(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredExternalCache)
	return err
}

const getExternalCache = `-- name: GetExternalCache :one
SELECT cache_key, response_json, expires_at
FROM external_api_cache
WHERE cache_key = $1 AND expires_at > NOW()
`

type GetExternalCacheRow struct {
	CacheKey     string    `json:"cache_key"`
	ResponseJson []byte    `json:"response_json"`
	ExpiresAt    time.Time `json:"expires_at"`
}

func (q *Queries) GetExternalCache(ctx context.Context, cacheKey string) (GetExternalCacheRow, error) {
	row := q.db.QueryRow(ctx, getExternalCache, cacheKey)
	var i GetExternalCacheRow
	err := row.Scan(&i.CacheKey, &i.ResponseJson, &i.ExpiresAt)
	return i, err
}

const upsertExternalCache = `-- name: UpsertExternalCache :exec
INSERT INTO external_api_cache (cache_key, response_json, expires_at, updated_at)
VALUES ($1, $2, $3, NOW())
    ON CONFLICT (cache_key)
DO UPDATE SET response_json = EXCLUDED.response_json,
           expires_at = EXCLUDED.expires_at,
           updated_at = NOW()
`

type UpsertExternalCacheParams struct {
	CacheKey     string    `json:"cache_key"`
	ResponseJson []byte    `json:"response_json"`
	ExpiresAt    time.Time `json:"expires_at"`
}

func (q *Queries) UpsertExternalCache(ctx context.Context, arg UpsertExternalCacheParams) error {
	_, err := q.db.Exec(ctx, upsertExternalCache, arg.CacheKey, arg.ResponseJson, arg.ExpiresAt)
	return err
}
